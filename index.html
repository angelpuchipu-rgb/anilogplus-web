<!DOCTYPE html>
<html lang="ja" class="dark">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>anilog+ (Web) v2.2-dev</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>tailwind.config = { darkMode: 'class' }</script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    html,
    body {
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      background: #f7f8fa;
      color: #111827;
    }

    .card {
      background: #ffffff;
      border: 1px solid #e5e7eb;
      /* gray-200 */
      border-radius: 16px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, .05);
    }


    .btn-ghost {
      background: rgba(0, 0, 0, 0.05);
    }


    .btn {
      background: #3F6EE6;
      box-shadow: 0 10px 30px -12px rgba(91, 140, 255, .45)
    }

    .btn:hover {
      background: #5B8CFF
    }

    .btn,
    .btn-ghost {
      padding: .55rem 1rem;
      border-radius: .8rem;
      display: inline-flex;
      align-items: center;
      gap: .5rem
    }

    .btn-ghost {
      background: rgba(0, 0, 0, 0.05);
    }

    .input,
    select,
    textarea {
      background: #fff;
      border: 1px solid #d1d5db;
      /* gray-300 */
      color: #111827;
      /* gray-900 */
      padding: .6rem .8rem;
      border-radius: .9rem;
      outline: none;
      width: 100%;
    }

    .input:focus,
    select:focus,
    textarea:focus {
      border-color: #3b82f6;
      /* blue-500 */
      box-shadow: 0 0 0 3px rgba(59, 130, 246, .28);
    }

    select option {
      color: #111827;
      background: #fff;
    }

    .chip {
      border: 1px solid rgba(255, 255, 255, .15);
      padding: .15rem .5rem;
      border-radius: 9999px;
      font-size: .75rem;
      cursor: pointer
    }

    .img-card {
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      cursor: pointer
    }

    .img-card img {
      width: 100%;
      height: 100%;
      object-fit: cover
    }


    .img-hint {
      position: absolute;
      inset: auto 8px 8px auto;
      background: rgba(0, 0, 0, .55);
      padding: .25rem .5rem;
      border-radius: .5rem;
      font-size: .75rem;
      opacity: 0;
      transition: .2s
    }

    .img-card:hover .img-hint {
      opacity: 1
    }

    .score-circle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 9999px;
      font-weight: 700;
      line-height: 1;
      width: 100px;
      height: 100px
    }

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .6);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100
    }

    .modal {
      width: min(900px, 88vw);
      max-height: 86vh;
      overflow: auto
    }


    .linklike {
      color: #8ab4ff;
      cursor: pointer
    }

    /* レビュー画像のホバーでヒントを出す */
    .review-img:hover .img-hint {
      opacity: 1;
    }

    .scrollbar-none::-webkit-scrollbar {
      display: none;
    }

    /* header内のUIを白基調に */
    header .btn-ghost {
      background: rgba(255, 255, 255, .15);
      color: #fff;
    }

    header .btn-ghost:hover {
      background: rgba(255, 255, 255, .25);
    }

    header #netBadge {
      background: rgba(255, 255, 255, .18);
      color: #fff;
    }

    /* rangeスライダーを見やすく */
    input[type="range"] {
      accent-color: #3b82f6;
      /* blue-500 */
      height: 6px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</head>

<body>
  <header class="sticky top-0 z-50 bg-blue-700 text-white shadow">
    <div class="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
      <button id="homeBtn" class="flex items-center gap-3">
        <div class="w-9 h-9 rounded-xl bg-blue-500 flex items-center justify-center font-bold">A+</div>
        <h1 class="text-xl font-semibold">anilog+ <span class="text-sm text-gray-500">web</span></h1>
      </button>
      <nav class="flex items-center gap-2 overflow-x-auto flex-nowrap scrollbar-none">
        <span id="netBadge" class="text-xs px-2 py-1 rounded bg-white/10">接続: 未検証</span>
        <span id="authState">未ログイン</span>
        <button id="navHome" class="btn-ghost shrink-0">ホーム</button>
        <button class="btn-ghost shrink-0" onclick="switchView('reviews')">レビュー</button>
        <button class="btn-ghost shrink-0" onclick="switchView('tier')">Tier表</button>
        <button class="btn-ghost shrink-0" onclick="switchView('settings')">設定</button>
        <button id="btnExport" class="btn shrink-0">JSON書出し</button>
        <label class="btn-ghost cursor-pointer shrink-0">
          JSON読込
          <input id="fileImport" type="file" accept="application/json" class="hidden">
        </label>



      </nav>
    </div>
  </header>

  <main class="max-w-7xl mx-auto p-4 space-y-8">
    <!-- レビュー数カウンター -->
    <div class="text-center my-6">
      <h2 class="text-xl font-bold text-gray-800">今まで見たアニメ本数</h2>
      <p class="text-5xl font-extrabold text-blue-500 mt-2" id="reviewCount">0</p>
    </div>


    <section id="view-search" class="space-y-4">
      <div class="card p-4 space-y-3">
        <div class="grid md:grid-cols-[1fr,260px] gap-3">
          <input id="q" class="input" placeholder="タイトル（例: 進撃の巨人 / NARUTO / 呪術廻戦）">
          <div class="flex gap-2">
            <select id="era" class="select w-full" title="2000年冬〜2025年秋">
              <option value="">年代別検索（例: 2024 秋）</option>
            </select>
            <button id="btnSearch" class="btn shrink-0">検索</button>
          </div>
        </div>
        <button id="btnClear" class="btn-ghost">入力クリア</button>
        <div id="results" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"></div>
        <div id="pager" class="flex justify-center gap-3"></div>
      </div>

      <div class="card p-4 space-y-2">
        <div class="flex items-center justify-between">
          <h3 class="font-semibold">流行りのアニメ</h3>
          <button class="btn-ghost text-sm" onclick="loadTrending()">更新</button>
        </div>
        <div id="trending" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 gap-3"></div>
      </div>
    </section>

    <section id="view-reviews" class="hidden space-y-4">
      <div class="card p-4 space-y-3">
        <!-- レビュー統計 -->
        <div id="reviewStats" class="text-center text-sm text-gray-700">件数: 0　平均点: -</div>

        <div class="flex flex-wrap gap-2 items-center">
          <select id="filterStatus" class="select">
            <option value="">全ステータス</option>
            <option value="SEEN">見た</option>
            <option value="WATCHING">見てる途中</option>
            <option value="WANT">見たい</option>
            <option value="DROP">途中切り</option>
          </select>
          <input id="filterTag" class="input" placeholder="タグで絞り込み（例: バトル）">
          <select id="sortBy" class="select">
            <option value="updatedAt">更新が新しい順</option>
            <option value="score">点数が高い順</option>
            <option value="title">タイトル順</option>
          </select>
        </div>
        <div id="reviewStats" class="text-sm text-white/70"></div>
        <div id="reviewList" class="grid md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
      </div>
    </section>

    <section id="view-tier" class="hidden space-y-3">
      <div class="flex items-center justify-between">
        <h3 class="font-semibold">Tier表メーカー</h3>
        <div class="flex gap-2">
          <button id="tierAdd" class="btn-ghost">段を追加</button>
          <button id="tierReset" class="btn-ghost">空にする</button>
          <button id="tierPng" class="btn">PNG保存</button>
        </div>
      </div>
      <div id="tierBoard" class="space-y-2"></div>
    </section>

    <section id="view-settings" class="hidden">
      <div class="card p-4 space-y-2">
        <h3 class="font-semibold">設定 / データ</h3>
        <button id="btnWipe" class="btn-ghost">すべてのローカルデータを削除</button>
        <p class="text-sm text-white/60">ブラウザのローカルストレージに保存されます。バックアップはJSONで。</p>
      </div>

      <!-- ▼▼ Supabase ログイン UI をここに追加 ▼▼ -->
      <div class="card p-4 space-y-3">
        <h3 class="font-semibold">アカウント</h3>
        <div class="grid sm:grid-cols-2 gap-2">
          <input id="authEmail" class="input" placeholder="メールアドレス">
          <input id="authPass" class="input" type="password" placeholder="パスワード">
        </div>
        <div class="flex gap-2">
          <button id="btnSignUp" class="btn-ghost">新規登録</button>
          <button id="btnSignIn" class="btn">ログイン</button>
          <button id="btnSignOut" class="btn-ghost">ログアウト</button>
        </div>
        <div id="authState" class="text-sm text-gray-500">未ログイン</div>
      </div>
      <!-- ▲▲ ここまで追加 ▲▲ -->
    </section>

  </main>

  <div id="overlay" class="overlay">
    <div class="modal card p-3 sm:p-5 space-y-4 rounded-2xl mx-2">
      <div class="flex flex-col sm:flex-row items-start gap-4">
        <!-- 左カラム：縦積みに変更 -->
        <div class="w-full sm:w-[240px] flex flex-col">
          <div class="img-card rounded overflow-hidden w-full" style="aspect-ratio: 2 / 3;">
            <img id="mCover" class="w-full h-full object-cover" alt="">
            <div class="img-hint">クリックで編集</div>
          </div>


          <!-- 画像の直下に関連シーズンを表示 -->
          <div id="mRelatedLeft" class="mt-3 hidden">
            <div class="text-xs text-gray-500">関連シーズン</div>
            <div id="mRelatedChipsLeft" class="mt-1 flex flex-wrap gap-2"></div>
          </div>
        </div>

        <div class="flex-1 space-y-2">
          <!-- 右カラム（タイトルや説明など） -->


          <div class="flex-1 space-y-2">
            <div class="text-lg font-semibold" id="mTitle"></div>
            <div class="text-xs text-gray-500" id="mMeta"></div>
            <div id="mDesc" class="text-sm text-white/80 max-h-40 overflow-auto"></div>

            <div id="mRelatedWrap" class="hidden">
              <div class="pt-2 border-t border-white/10"></div>
              <div class="text-sm font-semibold">関連シーズン</div>
              <div id="mRelated" class="flex flex-wrap gap-2"></div>
            </div>

            <div class="pt-2 border-t border-white/10"></div>
            <div class="grid sm:grid-cols-2 gap-3">
              <label class="text-sm text-gray-700">ステータス
                <select id="mStatus" class="select mt-1">
                  <option value="">未設定</option>
                  <option value="SEEN">見た</option>
                  <option value="WATCHING">見てる途中</option>
                  <option value="WANT">見たい</option>
                  <option value="DROP">途中切り</option>
                </select>
              </label>
              <label class="text-sm">点数（1〜100）
                <div class="flex items-center gap-3 mt-1">
                  <input id="mScore" type="range" min="1" max="100" value="80" class="w-full">
                  <input id="mScoreInput" type="number" min="1" max="100" value="80" class="input w-24 text-center">
                  <span id="mScoreCircle" class="score-circle text-base"></span>
                </div>
              </label>
            </div>
            <label class="text-sm">タグ（カンマ区切り）
              <input id="mTags" class="input mt-1" placeholder="ラブコメ, バトル, 学園...">
            </label>
            <label class="text-sm">感想・コメント
              <textarea id="mComment" class="input mt-1 h-28" placeholder="感想やメモ"></textarea>
            </label>
            <div class="flex justify-between items-center pt-2">
              <button id="btnDelete" class="btn-ghost text-red-300 hidden">削除</button>
              <div class="flex gap-2">
                <button id="btnClose" class="btn-ghost">閉じる</button>
                <button id="btnSave" class="btn">保存</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <template id="tpl-result">
      <div class="card overflow-hidden">
        <div class="img-card bg-gray-900 rounded-lg overflow-hidden" style="aspect-ratio: 2 / 3;">
          <img loading="lazy" decoding="async"
            class="max-w-full max-h-full object-contain transition-transform duration-300 hover:scale-105" alt="アニメ画像">
          <div class="img-hint">クリックして評価</div>
        </div>
        <div class="p-3 space-y-2">
          <div class="flex items-start justify-between gap-2">
            <div class="font-semibold leading-tight"></div>
            <span class="text-xs px-2 py-1 rounded bg-white/10"></span>
          </div>
          <div class="text-xs text-white/70 line-clamp-3 min-h-[3.5rem]" data-desc></div>
          <div class="flex flex-wrap gap-2 text-xs" data-chips></div>
          <div class="flex items-center justify-between pt-2">
            <button class="btn-ghost" data-edit>編集</button>
            <button class="btn-ghost" data-tier>Tierへ</button>
          </div>
        </div>
      </div>
    </template>


    <template id="tpl-review">
      <div
        class="card flex items-start p-4 rounded-lg bg-neutral-900/60 shadow-md hover:shadow-lg transition-shadow duration-300">
        <!-- アニメ画像 -->
        <div
          class="w-24 h-32 shrink-0 overflow-hidden rounded-lg shadow-md bg-gray-900 relative review-img cursor-pointer">
          <img class="w-full h-full object-cover transition-transform duration-300 hover:scale-105 cursor-pointer">
          <div class="img-hint">クリックして編集</div>
        </div>


        <!-- 情報エリア -->
        <div class="flex-1 ml-4">
          <!-- タイトル＋スコア -->
          <div class="flex items-start justify-between gap-2">
            <div id="mDesc" class="text-sm text-white/80 max-h-32 sm:max-h-40 overflow-auto"></div>
            <div class="text-lg font-bold text-blue-400 shrink-0" data-score></div>
          </div>

          <!-- 制作情報 -->
          <div class="mt-1 text-sm text-gray-300" data-meta></div>

          <!-- コメント -->
          <p class="mt-2 text-sm text-gray-400 leading-relaxed" data-comment></p>
        </div>
      </div>
    </template>

    <template id="tpl-tier-row">
      <div class="flex gap-2">
        <div class="flex items-center gap-2 bg-white/10 rounded px-2"><input
            class="bg-transparent outline-none w-12 font-bold" value="S"><button data-del
            class="text-gray-500">✕</button></div>
        <div data-zone
          class="grid grid-cols-[repeat(auto-fill,minmax(120px,1fr))] gap-2 flex-1 bg-white/5 rounded p-2 border border-white/10">
        </div>
      </div>
    </template>

    <script>
      const LS = 'anilogplus_v1', LS_TIER = 'anilogplus_tier';
      const state = { cache: {}, recs: load(LS) || {}, tier: load(LS_TIER) || [], provider: 'anilist', editingId: null };
      function save(k, v) { localStorage.setItem(k, JSON.stringify(v)) }
      function load(k) { try { return JSON.parse(localStorage.getItem(k) || 'null') } catch { return null } }
      function jpSeason(s) { return ({ WINTER: '冬', SPRING: '春', SUMMER: '夏', FALL: '秋' })[s] || s || '' }
      function colorForScore(n) { const hue = Math.round((n / 100) * 120); return `hsl(${hue} 80% 40%)` }
      function setCircle(el, n) { el.style.background = colorForScore(n); el.textContent = n; el.className = 'score-circle text-white' }

      (() => {
        const era = document.getElementById('era');
        const seasons = ['FALL', 'SUMMER', 'SPRING', 'WINTER'];
        for (let y = 2025; y >= 2000; y--) {
          for (const s of seasons) {
            if (y === 2025 && s === 'WINTER') continue;
            const o = document.createElement('option');
            o.value = y + '-' + s;
            o.textContent = `${y} ${jpSeason(s)}`;
            era.appendChild(o);
          }
        }
      })();

      function goHome() {
        // すべてのビューを非表示にする
        ['search', 'reviews', 'tier', 'settings'].forEach(id => {
          document.getElementById('view-' + id).classList.add('hidden');
        });

        // ホーム画面（検索画面）を表示する
        document.getElementById('view-search').classList.remove('hidden');

        // スクロールをトップに戻す
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
      document.getElementById('homeBtn').onclick = goHome;
      document.getElementById('navHome').onclick = goHome;

      q.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); search(1) } });
      era.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); search(1) } });

      function switchView(v) {
        ['search', 'reviews', 'tier', 'settings'].forEach(id => document.getElementById('view-' + id).classList.toggle('hidden', id !== v));
        if (v === 'reviews') renderReviews();
        if (v === 'tier') renderTier();
      }

      async function testConnections() {
        const badge = document.getElementById('netBadge');
        badge.textContent = '接続: AniList（テスト省略）';
        state.provider = 'anilist';
      }

      testConnections();

      async function loadTrending() {
        const wrap = document.getElementById('trending'); wrap.innerHTML = '<div class="text-gray-500">読み込み中…</div>';
        try {
          let items = [];
          if (state.provider === 'anilist') {
            const query = `query{ Page(perPage:12){ media(type:ANIME,sort:TRENDING_DESC){ id title{native romaji} coverImage{medium large} season seasonYear } } }`;
            const r = await fetch('https://graphql.anilist.co', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query }) });
            const j = await r.json(); items = j.data.Page.media.map(mapFromAniList);
          } else {
            const r = await fetch('https://api.jikan.moe/v4/top/anime?filter=bypopularity&limit=12'); const j = await r.json(); items = j.data.map(mapFromJikan);
          }
          wrap.innerHTML = '';
          items.forEach(m => {
            const div = document.createElement('div'); div.className = 'cursor-pointer';
            div.innerHTML = `<img src="${m.cover}" class="w-full h-28 object-contain bg-black/60 rounded"><div class="text-xs mt-1 line-clamp-2">${m.title}</div>`;
            div.onclick = () => openModal(m.id);
            wrap.appendChild(div);
          });
        } catch { wrap.innerHTML = '<div class="text-gray-500">取得に失敗しました</div>'; }
      }
      loadTrending();

      async function search(page = 1) {
        const kw = q.value.trim();
        const eraVal = era.value;
        let season, seasonYear;
        if (eraVal) { const [y, s] = eraVal.split('-'); seasonYear = Number(y); season = s; }
        try {
          let items = [], pageInfo = { currentPage: page, hasNextPage: false };
          if (state.provider === 'anilist') {
            const query = `query($page:Int,$perPage:Int,$search:String,$season:MediaSeason,$seasonYear:Int){
        Page(page:$page,perPage:$perPage){pageInfo{currentPage hasNextPage} media(type:ANIME,search:$search,season:$season,seasonYear:$seasonYear,sort:POPULARITY_DESC){
          id title{native romaji english} coverImage{large medium} season seasonYear description(asHtml:false)
          studios(isMain:true){nodes{name}} characters(role:MAIN, perPage:6){edges{node{name{full}} voiceActors(language:JAPANESE, perPage:1){name{full}}}}
        }}}`;
            const r = await fetch('https://graphql.anilist.co', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' }, body: JSON.stringify({ query, variables: { page, perPage: 18, search: kw || undefined, season, seasonYear } }) });
            if (!r.ok) throw new Error('AniList blocked'); const { data } = await r.json(); items = data.Page.media.map(mapFromAniList); pageInfo = data.Page.pageInfo;
            document.getElementById('netBadge').textContent = '接続: AniList';
          } else {
            let url = 'https://api.jikan.moe/v4/anime?order_by=members&sort=desc&sfw=true&limit=18&page=' + page;
            if (kw) url += '&q=' + encodeURIComponent(kw);
            if (!kw && season && seasonYear) { url = `https://api.jikan.moe/v4/seasons/${seasonYear}/${season.toLowerCase()}?limit=18&page=${page}`; }
            const r = await fetch(url, { mode: 'cors' }); if (!r.ok) throw new Error('Jikan failed'); const j = await r.json();
            items = (j.data || []).map(mapFromJikan); pageInfo = { currentPage: page, hasNextPage: !!j.pagination?.has_next_page };
            document.getElementById('netBadge').textContent = '接続: Jikan(MAL)';
          }
          renderResults(items, pageInfo);
        } catch (e) { if (state.provider === 'anilist') { state.provider = 'jikan'; return search(page); } document.getElementById('results').innerHTML = '<div class="text-white/70">検索に失敗しました。</div>'; }
      }
      document.getElementById('btnSearch').onclick = () => search(1);
      document.getElementById('btnClear').onclick = () => { q.value = ''; era.value = ''; search(1) };

      function mapFromAniList(m) { state.cache[m.id] = m; return { id: m.id, title: m.title.native || m.title.romaji || m.title.english, cover: m.coverImage.large || m.coverImage.medium, season: `${m.seasonYear || ''} ${jpSeason(m.season)}`.trim(), desc: (m.description || '').replace(/<br>/g, ' ').replace(/<\/?i>/g, ''), chips: [{ label: (m.studios?.nodes?.[0]?.name) || '—', kind: 'studio' }, ...((m.characters?.edges || []).map(e => ({ label: `${e.node.name.full}（${(e.voiceActors?.[0]?.name.full) || '—'}）`, kind: 'cast' })))].slice(0, 5) }; }
      function mapFromJikan(a) { const id = a.mal_id; const title = a.title_japanese || a.title; const cover = a.images?.jpg?.image_url || a.images?.webp?.image_url || ''; const seasonYear = a.year || ''; const season = (a.season || ''); const desc = (a.synopsis || ''); const studios = (a.studios?.[0]?.name) || '—'; state.cache[id] = { title: { native: title }, coverImage: { medium: cover, large: cover }, seasonYear, season: season.toUpperCase(), description: desc, studios: { nodes: [{ name: studios }] } }; return { id, title, cover, season: `${seasonYear} ${jpSeason((season || '').toUpperCase())}`.trim(), desc, chips: [{ label: studios, kind: 'studio' }] }; }

      function renderResults(list, pageInfo) {
        const wrap = document.getElementById('results'); wrap.innerHTML = '';
        const tpl = document.getElementById('tpl-result').content;
        list.forEach(m => {
          const n = tpl.cloneNode(true); const img = n.querySelector('img'); img.src = m.cover; img.alt = m.title; img.onclick = () => openModal(m.id); n.querySelector('.font-semibold').textContent = m.title; async function translateToJapanese(text) {
            const maxLength = 400; // APIの制限に合わせて文字数を制限
            const truncatedText = text.length > maxLength ? text.slice(0, maxLength) + '...' : text;
            const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(truncatedText)}&langpair=en|ja`);
            const data = await response.json();
            return data.responseData.translatedText || truncatedText;
          }

          (async () => {
            const description = m.desc || '';
            n.querySelector('[data-desc]').textContent = await translateToJapanese(description);
          })(); const chips = n.querySelector('[data-chips]'); (m.chips || []).forEach(t => { const s = document.createElement('span'); s.className = 'chip'; s.textContent = t.label; s.onclick = () => { if (t.kind === 'studio') searchByStudio(t.label); else { q.value = t.label; search(1); } }; chips.appendChild(s) }); n.querySelector('[data-edit]').onclick = () => openModal(m.id); n.querySelector('[data-tier]').onclick = () => addToTier(m.id); wrap.appendChild(n);
        });
        const pager = document.getElementById('pager'); pager.innerHTML = ''; const prev = document.createElement('button'); prev.className = 'btn-ghost'; prev.textContent = '« 前'; prev.disabled = pageInfo.currentPage <= 1; prev.onclick = () => search(pageInfo.currentPage - 1); const next = document.createElement('button'); next.className = 'btn-ghost'; next.textContent = '次 »'; next.disabled = !pageInfo.hasNextPage; next.onclick = () => search(pageInfo.currentPage + 1); pager.append(prev, next);
      }

      async function searchByStudio(name) {
        if (state.provider === 'anilist') {
          const query = `query($q:String){ Studio(search:$q){ name media(perPage:30, sort:POPULARITY_DESC){ nodes{ id title{native romaji} coverImage{medium} season seasonYear } } } }`;
          try {
            const r = await fetch('https://graphql.anilist.co', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query, variables: { q: name } }) });
            const j = await r.json();
            const m = (j.data?.Studio?.media?.nodes || []).map(mapFromAniList);
            renderResults(m, { currentPage: 1, hasNextPage: false });
            document.getElementById('netBadge').textContent = '接続: AniList';
            return;
          } catch { }
        }
        q.value = name; search(1);
      }

      async function fetchRelationsJikan(id) {
        try {
          const r = await fetch(`https://api.jikan.moe/v4/anime/${id}/relations`);
          const j = await r.json();
          const edges = j.data || [];
          // Prequel / Sequel のみ抽出
          const entries = edges
            .filter(e => e.relation === 'Prequel' || e.relation === 'Sequel')
            .flatMap(e => e.entry || []);
          // AniList版に寄せた軽量オブジェクトへ
          return entries.map(e => ({
            id: e.mal_id,
            title: { native: e.name },
            seasonYear: null,
            season: null,
            coverImage: { medium: '' }
          }));
        } catch {
          return [];
        }
      }
      // AniList側の関連取得（ダミー定義：エラー回避用）
      async function fetchRelationsAniList(id) {
        console.log("fetchRelationsAniList は現在未使用です（ダミー定義）");
        return [];
      }



      function openModal(id) {
        state.editingId = id;
        let m = state.cache[id];
        const rec = state.recs[id] || { score: 80 };
        if (!m && rec.meta) {
          m = { title: { native: rec.meta.title }, coverImage: { large: rec.meta.cover, medium: rec.meta.cover }, seasonYear: rec.meta.seasonYear, season: rec.meta.season, description: rec.meta.description, studios: { nodes: [{ name: rec.meta.studio || '—' }] } };
          state.cache[id] = m;
        }
        mCover.src = m?.coverImage?.large
          || m?.coverImage?.medium
          || rec?.meta?.cover       // ← 追加
          || '';
        // 「削除」ボタンの表示/非表示（既にあります）
        document.getElementById('btnDelete').classList.toggle('hidden', !state.recs[id]);

        // ここを追加：削除のイベントをバインド
        btnDelete.onclick = async () => {
          if (!state.editingId) return;
          if (!confirm('このレビューを削除しますか？')) return;
          await removeReview(state.editingId);
          closeModal();
          await syncFromCloud();  // 念のため直後に同期
        };


        mTitle.textContent = m?.title?.native || m?.title?.romaji || m?.title?.english || ('ID ' + id);
        mMeta.textContent = `${m?.seasonYear || ''} ${jpSeason(m?.season)} / ${(m?.studios?.nodes?.[0]?.name) || '—'}`;
        async function translateToJapanese(text) {
          const maxLength = 400; // APIの制限に合わせて文字数を制限
          const truncatedText = text.length > maxLength ? text.slice(0, maxLength) + '...' : text;
          try {
            const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(truncatedText)}&langpair=en|ja`);
            const data = await response.json();
            return data.responseData.translatedText || truncatedText;
          } catch (error) {
            console.error('翻訳エラー:', error);
            return text; // 翻訳失敗時は元のテキストを返す
          }
        }

        (async () => {
          const description = m?.description || '';
          mDesc.textContent = await translateToJapanese(description);
        })();
        // デフォルトステータスを「見た」に設定
        mStatus.value = rec.status || 'SEEN';

        mScore.value = rec.score || 80; mScoreInput.value = rec.score || 80; setCircle(mScoreCircle, rec.score || 80);
        mTags.value = (rec.tags || []).join(', ');
        mComment.value = rec.comment || '';
        document.getElementById('btnDelete').classList.toggle('hidden', !state.recs[id]);
        overlay.style.display = 'flex';

        (async () => {
          const rightWrap = document.getElementById('mRelated');
          const rightSec = document.getElementById('mRelatedWrap');
          const leftSec = document.getElementById('mRelatedLeft');
          const leftChips = document.getElementById('mRelatedChipsLeft');

          if (rightWrap) rightWrap.innerHTML = '';
          if (leftChips) leftChips.innerHTML = '';
          if (leftSec) leftSec.classList.add('hidden');

          // 関連の取得（AniList優先、必要ならJikanにフォールバック）
          let list = [];
          if (state.provider === 'anilist') {
            list = await fetchRelationsAniList(id);
            // 画像など最低限のメタをキャッシュに補完
            async function ensureCachedMeta(id) {
              const m = state.cache[id];
              if (m && (m.coverImage?.large || m.coverImage?.medium)) return;

              try {
                if (state.provider === 'anilist') {
                  const query = `query($id:Int){
        Media(id:$id,type:ANIME){
          id title{native romaji english}
          coverImage{large medium}
          season seasonYear
          description(asHtml:false)
          studios(isMain:true){nodes{name}}
        }
      }`;
                  const r = await fetch('https://graphql.anilist.co', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query, variables: { id } })
                  });
                  const j = await r.json();
                  const a = j.data?.Media;
                  if (a) {
                    state.cache[id] = {
                      title: a.title,
                      coverImage: a.coverImage,
                      season: a.season,
                      seasonYear: a.seasonYear,
                      description: a.description,
                      studios: a.studios
                    };
                  }
                } else {
                  const r = await fetch(`https://api.jikan.moe/v4/anime/${id}`);
                  const j = await r.json();
                  const a = j.data;
                  if (a) {
                    state.cache[id] = {
                      title: { native: a.title_japanese || a.title },
                      coverImage: {
                        large: a.images?.jpg?.large_image_url || a.images?.webp?.large_image_url,
                        medium: a.images?.jpg?.image_url || a.images?.webp?.image_url
                      },
                      season: (a.season || '').toUpperCase(),
                      seasonYear: a.year || '',
                      description: a.synopsis || '',
                      studios: { nodes: [{ name: a.studios?.[0]?.name || '—' }] }
                    };
                  }
                }
              } catch (e) { }
            }

          } else if (typeof fetchRelationsJikan === 'function') {
            list = await fetchRelationsJikan(id);
          }

          if (Array.isArray(list) && list.length) {
            list.sort((a, b) => (b.seasonYear || 0) - (a.seasonYear || 0));
            if (leftSec) leftSec.classList.remove('hidden');

            list.forEach(x => {
              const b = document.createElement('button');
              b.className = 'chip';
              b.textContent =
                (x.title?.native || x.title?.romaji || '') +
                (x.seasonYear ? ` ${x.seasonYear}` : '') +
                (x.season ? ` ${jpSeason(x.season)}` : '');
              b.onclick = async () => {
                await ensureCachedMeta(x.id);
                openModal(x.id);
              };

              leftChips.appendChild(b);

              // 軽いキャッシュ補完（後続表示のため）
              state.cache[x.id] = Object.assign(state.cache[x.id] || {}, {
                title: x.title,
                coverImage: { medium: x.coverImage?.medium },
                season: x.season,
                seasonYear: x.seasonYear
              });
            });

            // 右側の旧枠は隠す（重複回避）
            if (rightSec) rightSec.classList.add('hidden');
          } else {
            if (rightSec) rightSec.classList.add('hidden');
            if (leftSec) leftSec.classList.add('hidden');
          }
        })();



      }
      function closeModal() { overlay.style.display = 'none'; }
      mScore.oninput = e => { mScoreInput.value = e.target.value; setCircle(mScoreCircle, Number(e.target.value)); }
      mScoreInput.oninput = e => { const v = Math.max(1, Math.min(100, Number(e.target.value) || 1)); mScore.value = v; setCircle(mScoreCircle, v); }
      btnClose.onclick = closeModal;
      btnSave.onclick = async () => {
        const id = state.editingId;
        if (!id) return;
        const m = state.cache[id] || {};
        const meta = {
          title: m.title?.native || m.title?.romaji || m.title?.english || ('ID ' + id),
          cover: m.coverImage?.large || m.coverImage?.medium || '',
          studio: m.studios?.nodes?.[0]?.name || '—',
          seasonYear: m.seasonYear || '',
          season: m.season || '',
          description: m.description || ''
        };
        const tags = mTags.value.split(',').map(s => s.trim()).filter(Boolean);
        const rec = { status: mStatus.value, score: Number(mScore.value), tags, comment: mComment.value, updatedAt: Date.now(), meta };
        state.recs[id] = rec;
        save(LS, state.recs);
        await saveReviewToCloud(id, rec); // ← クラウドへ送信
        await syncFromCloud();            // ← 直後に反映
        closeModal();
        alert('保存しました');
      };

      btnWipe.onclick = async () => {
        if (!confirm('全データを削除しますか？')) return;
        await removeAllReviewsOfCurrentUser(); // ← クラウドも削除
        alert('削除しました');
        switchView('search');
      };



      function renderReviews() {
        const fs = filterStatus.value,
          ft = (filterTag.value || '').toLowerCase(),
          sb = sortBy.value;

        let rows = Object.entries(state.recs).map(([id, rec]) => ({
          id: Number(id),
          rec,
          m: state.cache[id] || rec.meta
            ? { title: { native: rec.meta?.title }, coverImage: { large: rec.meta?.coverImage } }
            : {}
        }));

        rows = rows
          .filter(r => !fs || r.rec.status === fs)
          .filter(r => !ft || (r.rec.tags || []).some(t => t.toLowerCase().includes(ft)));

        rows.sort((a, b) =>
          sb === 'score'
            ? (b.rec.score || 0) - (a.rec.score || 0)
            : sb === 'title'
              ? (a.m?.title?.native || a.rec.meta?.title || '').localeCompare(b.m?.title?.native || b.rec.meta?.title || '')
              : 0
        );

        // 平均点と件数を計算
        const avg = rows.length
          ? (rows.reduce((s, r) => s + (r.rec.score || 0), 0) / rows.length).toFixed(1)
          : '-';

        // ← ここに安全な代入処理を追加！
        const statsEl = document.getElementById('reviewStats');
        if (statsEl) statsEl.textContent = `件数: ${rows.length}　平均点: ${avg}`;

        const countEl = document.getElementById('reviewCount');
        if (countEl) countEl.textContent = rows.length;

        // レビュー一覧描画（安全ガードつき）
        const listEl = document.getElementById('reviewList');
        if (!listEl) return;
        listEl.innerHTML = '';

        const tpl = document.getElementById('tpl-review').content;

        rows.forEach(({ id, rec, m }) => {
          const n = tpl.cloneNode(true);
          const img = n.querySelector('img');
          const metaEl = n.querySelector('[data-meta]');
          const scoreEl = n.querySelector('[data-score]');
          const commentEl = n.querySelector('[data-comment]');

          // 画像・タイトルなどは cache が無ければ rec.meta を使用
          const title =
            m?.title?.native ||
            rec.meta?.title ||
            ('ID ' + id);

          const cover =
            m?.coverImage?.medium ||
            m?.coverImage?.large ||
            rec.meta?.cover ||
            '';

          img.src = cover;
          img.alt = title;
          img.onclick = () => openModal(id);

          scoreEl.textContent = (rec.score ?? '-') + '';
          metaEl.textContent = `${rec.meta?.seasonYear || ''} ${rec.meta?.season || ''} / ${rec.meta?.studio || '—'}`;
          commentEl.textContent = rec.comment || '';

          listEl.appendChild(n);
        });


        // 以下：カードを並べる部分（元のコードのままでOK）
      }

      filterStatus.onchange = renderReviews; filterTag.oninput = () => { clearTimeout(window.__ft); window.__ft = setTimeout(renderReviews, 250) }; sortBy.onchange = renderReviews;

      function ensureTier() { if (!state.tier.length) state.tier = [{ label: 'S', items: [] }, { label: 'A', items: [] }, { label: 'B', items: [] }, { label: 'C', items: [] }]; }
      function renderTier() { ensureTier(); tierBoard.innerHTML = ''; state.tier.forEach((row, i) => { const t = document.getElementById('tpl-tier-row').content; const n = t.cloneNode(true); const input = n.querySelector('input'); input.value = row.label; input.onchange = () => { row.label = input.value; save(LS_TIER, state.tier) }; n.querySelector('[data-del]').onclick = () => { state.tier.splice(i, 1); save(LS_TIER, state.tier); renderTier() }; const zone = n.querySelector('[data-zone]'); row.items.forEach(id => { const m = state.cache[id] || state.recs[id]?.meta ? { coverImage: { medium: state.recs[id].meta.cover }, title: { native: state.recs[id].meta.title } } : null; const card = document.createElement('div'); card.className = 'rounded overflow-hidden border border-white/10 bg-black/40'; card.dataset.id = id; card.innerHTML = `<img src="${m?.coverImage?.medium || ''}" class="w-full h-32 object-contain bg-black/60"><div class="p-2 text-xs">${m?.title?.native || ('ID ' + id)}</div>`; zone.appendChild(card) }); new Sortable(zone, { group: 'tier', animation: 150, onAdd: saveTierFromDOM, onUpdate: saveTierFromDOM, onRemove: saveTierFromDOM }); tierBoard.appendChild(n); }); }
      function saveTierFromDOM() { const rows = [...document.querySelectorAll('#tierBoard [data-zone]')]; state.tier = rows.map((zone, i) => ({ label: document.querySelectorAll('#tierBoard input')[i].value, items: [...zone.children].map(el => Number(el.dataset.id)) })); save(LS_TIER, state.tier); }
      function addToTier(id) { ensureTier(); if (!state.tier[0].items.includes(id)) { state.tier[0].items.push(id); save(LS_TIER, state.tier); renderTier(); } }
      tierAdd.onclick = () => { state.tier.push({ label: '新段', items: [] }); save(LS_TIER, state.tier); renderTier() };
      tierReset.onclick = () => { if (confirm('Tier表を空にしますか？')) { state.tier = []; save(LS_TIER, state.tier); renderTier() } };
      tierPng.onclick = async () => { const canvas = await html2canvas(tierBoard, { backgroundColor: '#050914', scale: 2 }); const a = document.createElement('a'); a.download = 'anilogplus-tier.png'; a.href = canvas.toDataURL('image/png'); a.click(); };

      btnExport.onclick = () => { const blob = new Blob([JSON.stringify({ records: state.recs, tier: state.tier, version: 4 }, null, 2)], { type: 'application/json' }); const a = document.createElement('a'); a.download = 'anilogplus-data.json'; a.href = URL.createObjectURL(blob); a.click(); };
      fileImport.onchange = async e => { const f = e.target.files[0]; if (!f) return; try { const t = await f.text(); const j = JSON.parse(t); if (j.records) state.recs = j.records; if (j.tier) state.tier = j.tier; save(LS, state.recs); save(LS_TIER, state.tier); alert('読み込みました'); renderReviews(); renderTier() } catch { alert('JSON形式が不正です') } };
      btnWipe.onclick = () => { if (confirm('本当に削除しますか？')) { localStorage.removeItem(LS); localStorage.removeItem(LS_TIER); state.recs = {}; state.tier = []; alert('削除しました'); } };

      switchView('search');
    </script>
    <!-- ▼ Supabase ログイン＆同期スクリプト ▼ -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
      // ★あなたの Supabase プロジェクトの情報に置き換える！
      const SUPA_URL = "https://zrfrllgbsyttxmfvswfx.supabase.co";   // ← 自分のURL
      const SUPA_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpyZnJsbGdic3l0dHhtZnZzd2Z4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEyMjI0NDAsImV4cCI6MjA3Njc5ODQ0MH0.yw7Ld1Q2e-ITOPlDlZR4WRUReZvRuIg8vt_bYYOenVs";    // ← 自分の anon キー
      const supa = supabase.createClient(SUPA_URL, SUPA_ANON);

      let currentUser = null;

      (async function initAuth() {
        const { data } = await supa.auth.getUser();
        currentUser = data.user || null;
        document.getElementById('authState').textContent =
          currentUser ? `ログイン中: ${currentUser.email}` : '未ログイン';
        if (currentUser) await syncFromCloud();
      })();

      // Supabase にレビューを保存
      async function saveReviewToCloud(animeId, rec) {
        if (!currentUser) return;

        const payload = {
          user_id: currentUser.id,
          anime_id: animeId,
          rec_jsonb: rec
        };

        const { error } = await supa
          .from('reviews')
          .upsert(payload, { onConflict: 'user_id,anime_id' });

        if (error) console.error('saveReviewToCloud error:', error);
      }

      // ===============================
      // レビュー削除処理（クラウド同期対応）
      // ===============================

      // 1件削除（ローカル → クラウド）
      // --- 1件削除（ローカル → クラウド） ---
      async function removeReview(id) {
        // ローカルを削除
        delete state.recs[id];
        save(LS, state.recs);
        renderReviews();

        // クラウドを削除
        if (currentUser) {
          const { error } = await supa
            .from('reviews')
            .delete()
            .match({ user_id: currentUser.id, anime_id: Number(id) });

          if (error) {
            console.error('cloud delete error:', error);
            alert('クラウド削除に失敗しました。通信状況を確認してください。');
            await syncFromCloud(); // 再同期
          }
        }
      }

      // --- 全削除（ローカル + クラウド） ---
      async function removeAllReviewsOfCurrentUser() {
        if (currentUser) {
          const { error } = await supa
            .from('reviews')
            .delete()
            .eq('user_id', currentUser.id);
          if (error) {
            console.error('cloud wipe error:', error);
            alert('クラウド全削除に失敗しました。');
          }
        }

        // ローカルも消す
        state.recs = {};
        save(LS, state.recs);
        renderReviews();
      }

      async function removeReview(id) {
        // ローカルを先に消す
        delete state.recs[id];
        save(LS, state.recs);
        renderReviews();

        // クラウドを削除
        if (currentUser) {
          const { error } = await supa
            .from('reviews')
            .delete()
            .match({ user_id: currentUser.id, anime_id: Number(id) });

          if (error) {
            console.error('cloud delete error:', error);
            alert('クラウド削除に失敗しました。通信状況を確認してください。');
            await syncFromCloud(); // サーバー側を再読込して整合
          }
        }
      }

      // そのユーザーの全レビューを削除
      async function removeAllReviewsOfCurrentUser() {
        if (currentUser) {
          const { error } = await supa
            .from('reviews')
            .delete()
            .eq('user_id', currentUser.id);
          if (error) {
            console.error('cloud wipe error:', error);
            alert('クラウド全削除に失敗しました。');
          }
        }
        // ローカルもクリア
        state.recs = {};
        save(LS, state.recs);
        renderReviews();
      }



      const { error } = await supa
        .from('reviews')
        .upsert(payload, { onConflict: 'user_id,anime_id' });

      if (error) console.error('saveReviewToCloud error:', error);
      }


      // Supabase からレビューを同期
      async function syncFromCloud() {
        if (!currentUser) return;

        const { data, error } = await supa
          .from('reviews')
          .select('anime_id, rec_jsonb')
          .eq('user_id', currentUser.id)
          .order('updated_at', { ascending: false });

        if (error) {
          console.error('syncFromCloud error:', error);
          return;
        }

        // ← ここがポイント：id→rec の連想オブジェクトに整形
        const obj = {};
        (data || []).forEach(r => {
          obj[String(r.anime_id)] = r.rec_jsonb || {};
        });

        state.recs = obj;
        save(LS, state.recs);
        renderReviews();
      }




      // 保存ボタン上書き（既存のままでOK）
      const fileEl = document.getElementById('fileImport');
      if (fileEl) {
        fileEl.onchange = async (e) => {
          const f = e.target.files?.[0];
          if (!f) return;
          try {
            const txt = await f.text();
            const j = JSON.parse(txt);
            if (j.records) state.recs = j.records;
            if (j.tier) state.tier = j.tier;
            save(LS, state.recs); save(LS_TIER, state.tier);
            if (typeof renderReviews === 'function') renderReviews();
            if (typeof renderTier === 'function') renderTier();
            alert('読み込みました');
          } catch (err) {
            console.error(err);
            alert('JSONの形式が不正です');
          }
        };
      }


    </script>

    <!-- ▲ Supabase ログイン＆同期スクリプト ▲ -->
    <script>
      // ユーティリティ
      const $ = (id) => document.getElementById(id);

      // 画面反映
      function setAuthState(user) {
        const s = $('authState');
        if (!s) return;
        s.textContent = user ? `ログイン中: ${user.email}` : '未ログイン';
      }

      // ページ読み込み時に現在のログイン状態を反映
      (async () => {
        const { data } = await supa.auth.getUser();
        setAuthState(data.user || null);
      })();

      // 状態変化（メール確認後の戻りなど）も拾う
      supa.auth.onAuthStateChange(async (_event, session) => {
        setAuthState(session?.user || null);
      });

      // 新規登録
      $('btnSignUp')?.addEventListener('click', async () => {
        const email = $('authEmail')?.value.trim();
        const password = $('authPass')?.value;
        if (!email || !password) return alert('メールとパスワードを入力してください');
        const { error } = await supa.auth.signUp({
          email,
          password,
          options: {
            // 認証メール後の戻り先（SupabaseのSite URLと一致させる）
            emailRedirectTo: 'https://angelpuchipu-rgb.github.io/anilogplus-web/'
          }
        });
        if (error) alert(error.message);
        else alert('確認メールを送信しました。メール内のリンクを開いてください。');
      });

      // ログイン
      $('btnSignIn')?.addEventListener('click', async () => {
        const email = $('authEmail')?.value.trim();
        const password = $('authPass')?.value;
        if (!email || !password) return alert('メールとパスワードを入力してください');
        const { data, error } = await supa.auth.signInWithPassword({ email, password });
        if (error) return alert(error.message);
        setAuthState(data.user);
        // 必要ならクラウド→ローカル同期をここで
        if (typeof syncFromCloud === 'function') await syncFromCloud();
      });

      // ログアウト
      $('btnSignOut')?.addEventListener('click', async () => {
        await supa.auth.signOut();
        setAuthState(null);
      });
    </script>


</body>

</html>